{"pii": "S0022000097914926", "abstracts": {"#name": "abstracts", "$": {"xmlns:ce": true, "xmlns:dm": true, "xmlns:sb": true}, "$$": [{"#name": "abstract", "$": {"class": "author", "id": "aep-abstract-id5"}, "$$": [{"#name": "section-title", "_": "Abstract"}, {"#name": "abstract-sec", "$": {"id": "aep-abstract-sec-id6"}, "$$": [{"#name": "simple-para", "$": {"id": "simple-para0005", "view": "all"}, "$$": [{"#name": "__text__", "_": "The architecture of \u201cmesh of buses\u201d is an important model in parallel computing. Its main advantage is that the additional broadcast capability can be used to overcome the main disadvantage of the mesh, namely its relatively large diameter. We show that the addition of buses indeed accelerates routing times. Furthermore, unlike in the \u201cstore and forward\u201d model, the routing time becomes proportional to the network load, resulting in decreasing in routing time for a smaller number of packets. We consider 1\u20131 routing of"}, {"#name": "italic", "_": "m"}, {"#name": "__text__", "_": "packets in a"}, {"#name": "italic", "_": "d"}, {"#name": "__text__", "_": "-dimensional mesh with"}, {"#name": "italic", "$$": [{"#name": "__text__", "_": "n"}, {"#name": "sup", "$": {"loc": "post"}, "_": "d"}]}, {"#name": "__text__", "_": "processors and"}, {"#name": "italic", "_": "d"}, {"#name": "__text__", "_": "\u00b7"}, {"#name": "italic", "_": "n"}, {"#name": "sup", "$": {"loc": "post"}, "$$": [{"#name": "italic", "_": "d"}, {"#name": "__text__", "_": "\u22121"}]}, {"#name": "__text__", "_": "buses (one per row and column). The two standard models of accessing the buses are considered and compared: CREW, in which only one processor may transmit at any given time on a given bus, and the CRCW model, in which several processors may attempt to transmit at the same time (getting a noise signal as a result). We design a routing algorithm that routes"}, {"#name": "italic", "_": "m"}, {"#name": "__text__", "_": "packets in the CREW model in"}, {"#name": "italic", "_": "O"}, {"#name": "__text__", "_": "("}, {"#name": "italic", "_": "m"}, {"#name": "sup", "$": {"loc": "post"}, "$$": [{"#name": "__text__", "_": "1/"}, {"#name": "italic", "_": "d"}]}, {"#name": "__text__", "_": "+"}, {"#name": "italic", "_": "n"}, {"#name": "sup", "$": {"loc": "post"}, "$$": [{"#name": "__text__", "_": "1/("}, {"#name": "italic", "_": "d"}, {"#name": "__text__", "_": "+1)"}]}, {"#name": "__text__", "_": ") steps. This result holds for"}, {"#name": "italic", "_": "m"}, {"#name": "__text__", "_": "\u2a7d"}, {"#name": "italic", "_": "n"}, {"#name": "sup", "$": {"loc": "post"}, "$$": [{"#name": "__text__", "_": "2"}, {"#name": "italic", "_": "d"}, {"#name": "__text__", "_": "/3"}]}, {"#name": "__text__", "_": "for"}, {"#name": "italic", "_": "d"}, {"#name": "__text__", "_": "\u2a7e3 and unconditionally for"}, {"#name": "italic", "_": "d"}, {"#name": "__text__", "_": "=2. A matching lower bound is also proved. In the CRCW case we show an algorithm of"}, {"#name": "italic", "_": "O"}, {"#name": "__text__", "_": "("}, {"#name": "italic", "_": "m"}, {"#name": "sup", "$": {"loc": "post"}, "$$": [{"#name": "__text__", "_": "1/"}, {"#name": "italic", "_": "d"}]}, {"#name": "hsp", "$": {"sp": "0.25"}}, {"#name": "__text__", "_": "log"}, {"#name": "hsp", "$": {"sp": "0.25"}}, {"#name": "italic", "_": "n"}, {"#name": "__text__", "_": ") and a lower bound of"}, {"#name": "italic", "_": "\u03a9"}, {"#name": "__text__", "_": "("}, {"#name": "italic", "_": "m"}, {"#name": "sup", "$": {"loc": "post"}, "$$": [{"#name": "__text__", "_": "1/"}, {"#name": "italic", "_": "d"}]}, {"#name": "__text__", "_": "). It is shown that the difference between the models is essentially due to the improved capability of estimating threshold functions in the CRCW case."}]}]}]}]}}